<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: term_writer.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: term_writer.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>var inherits = require('util').inherits;

var CSI_PATTERN = /^\x1b\[([?!>]?)([0-9;]*)([@A-Za-z`]?)/;
var DCS_PATTERN = /^\x1bP([0-9;@A-Za-z`]*)\x1b\\/;
var OSC_PATTERN = /^\x1b\]([0-9]+);([^\x07]*)(\x07?)/;

/**
* TermWriter is the glue between a TerminalBuffer and the escape sequence
* interpreters.
* @constructor
*/
function TermWriter(buffer) {
	TermWriter.super_.call(this, { decodeStrings: false });
	this.buffer = buffer;
	this.oldChunk = null;
}
inherits(TermWriter, require('stream').Writable);
module.exports = TermWriter;

TermWriter.prototype.handlers = {
	chr: require('./handler/chr.js'),
	esc: require('./handler/esc.js'),
	csi: require('./handler/csi.js'),
	sgr: require('./handler/sgr.js'),
	dcs: require('./handler/dcs.js'),
	mode: require('./handler/mode.js'),
	osc: require('./handler/osc.js'),
};

/**
* Takes a chunk of data, interprets its escape sequences, and fills backend buffer
* @alias TermWriter.prototype.write
* @see http://nodejs.org/docs/latest/api/stream.html#stream_writable_write_chunk_encoding_callback
*/
TermWriter.prototype._write = function(chunk, encoding, callback) {
	var len = 1;
	if(typeof chunk !== 'string')
		chunk = chunk.toString();

	if(this.oldChunk !== null) {
		chunk = this.oldChunk + chunk;
		this.oldChunk = null;
	}

	while(chunk.length > 0 && len > 0) {
		len = this.callHandler('chr', chunk[0], chunk);
		if(len === null) {
			for(len = 1; len &lt; chunk.length &&
				!(chunk[len] in this.handlers.chr); len++);

			this.buffer.write(chunk.substr(0, len));
		}

		if(len > 0)
			chunk = chunk.slice(len);
	}
	if(chunk.length !== 0)
		this.oldChunk = chunk;
	this.emit('ready');
	callback();
};

/**
* calls an handler 
* @param type {string} one of the following types:
* &lt;ul>
* &lt;li>chr: interprets special characters (such as \r or \b)&lt;/li>
* &lt;li>esc: interprets simple escape characters starting with \x1b&lt;/li>
* &lt;li>csi: interprets CSI escape sequences&lt;/li>
* &lt;li>sgr: interprets SGR escape sequences&lt;/li>
* &lt;li>dcs: interprets DCS escape sequences&lt;/li>
* &lt;li>mode: interprets mode sequences&lt;/li>
* &lt;li>osc: interpretes OSC escape sequences&lt;/li>
* &lt;/ul>
* @param cmd {string} command to execute
* @param ... {...array} passed to the command function
*/
TermWriter.prototype.callHandler = function(type, cmd) {
	if(!(type in this.handlers && cmd in this.handlers[type]))
		return null;
	
	var args = Array.prototype.slice.call(arguments, 1);
	if(typeof this.handlers[type][cmd] === 'string')
		cmd = this.handlers[type][cmd];

	result = this.handlers[type][cmd].apply(this, args);
	return result === undefined ? 1 : result;
};

/**
* reads a CSI command sequence from a chunk of data
* @params chunk {string} a chunk of data to parse
* @returns {{args: Number|Array, mod: String, cmd: String, length: Number}}
*/
TermWriter.prototype.parseCsi = function(chunk) {
	var i;
	var match = CSI_PATTERN.exec(chunk);
	if(match === null)
		return null;
	var args = match[2] === "" ? [] : match[2].split(';');
	for(i = 0; i &lt; args.length; i++)
		args[i] = +args[i];
	return {
		args: args,
		mod: match[1],
		cmd: match[3],
		length: match[0].length
	};
};

/**
* reads a OSC command sequence from a chunk of data
* @params chunk {string} a chunk of data to parse
* @returns {{args: String|Array, mod: String, cmd: String, length: Number,
* terminated: Boolean}}
*/
TermWriter.prototype.parseOsc = function(chunk) {
	var match = OSC_PATTERN.exec(chunk);
	if(match === null)
		return null;
	return {
		args: match[2].split(';'),
		cmd: match[1],
		terminated: match[3] === '\x07',
		length: match[0].length
	};
};

/**
* reads a OSC command sequence from a chunk of data
* @params chunk {string} a chunk of data to parse
* @returns {{args: String|Array, mod: String, cmd: String, length: Number}}
*/
TermWriter.prototype.parseDcs = function(chunk) {
	var i;
	var match = DCS_PATTERN.exec(chunk);
	if(match === null)
		return null;
	return {
		args: [null,null],
		mod: match[1],
		cmd: match[1],
		length: match[0].length
	};
};

/**
* @see TermBuffer.prototype.toString
*/
TermWriter.prototype.toString = function() {
	return this.buffer.toString.apply(this.buffer, arguments);
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="TermBuffer.html">TermBuffer</a></li><li><a href="Terminal.html">Terminal</a></li><li><a href="TermWriter.html">TermWriter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#chr">chr</a></li><li><a href="global.html#csi">csi</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Tue May 20 2014 19:23:29 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
